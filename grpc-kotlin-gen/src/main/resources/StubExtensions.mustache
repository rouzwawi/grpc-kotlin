{{#packageName}}
package {{packageName}}
{{/packageName}}

import io.rouz.grpc.*
import {{packageName}}.{{serviceName}}Grpc.{{serviceName}}Stub

import kotlinx.coroutines.channels.ReceiveChannel
import kotlin.coroutines.suspendCoroutine

/**
 * Kotlin extension functions for [{{packageName}}.{{serviceName}}Grpc.{{serviceName}}Stub]
 *
 * Generated by gRPC Kotlin generator
 * Source: {{protoName}}
 */

{{#methods}}
{{#javaDoc}}{{{javaDoc}}}{{/javaDoc}}
{{#deprecated}}@Deprecated("deprecated"){{/deprecated}}
{{^isManyInput}}
{{^isManyOutput}}
{{! == unary req, unary resp == }}
inline suspend fun {{serviceName}}Stub.{{methodName}}(request: {{inputType}}): {{outputType}} {
    return suspendCoroutine {
        {{methodName}}(request, ContinuationStreamObserver(it))
    }
}
{{/isManyOutput}}
{{#isManyOutput}}
{{! == unary req, streaming resp == }}
fun {{serviceName}}Stub.{{methodName}}(request: {{inputType}}): ReceiveChannel<{{outputType}}> {
    val responseChannel = StreamObserverChannel<{{outputType}}>()
    {{methodName}}(request, responseChannel)
    return responseChannel
}
{{/isManyOutput}}
{{/isManyInput}}
{{#isManyInput}}
{{^isManyOutput}}
{{! == streaming req, unary resp == }}
fun {{serviceName}}Stub.{{methodName}}(): ManyToOneCall<{{inputType}}, {{outputType}}> {
    val responseDeferred = StreamObserverDeferred<{{outputType}}>()
    val requestObserver = {{methodName}}(responseDeferred)
    return ManyToOneCall(requestObserver, responseDeferred)
}
{{/isManyOutput}}
{{#isManyOutput}}
{{! == streaming req, streaming resp == }}
fun {{serviceName}}Stub.{{methodName}}(): ManyToManyCall<{{inputType}}, {{outputType}}> {
    val responseChannel = StreamObserverChannel<{{outputType}}>()
    val requestObserver = {{methodName}}(responseChannel)
    return ManyToManyCall(requestObserver, responseChannel)
}
{{/isManyOutput}}
{{/isManyInput}}
{{/methods}}
